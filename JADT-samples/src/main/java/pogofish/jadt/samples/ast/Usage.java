    package pogofish.jadt.samples.ast;
    
    
    import static java.util.Arrays.asList;
    import static pogofish.jadt.samples.ast.Arg._Arg;
    import static pogofish.jadt.samples.ast.Expression._Add;
    import static pogofish.jadt.samples.ast.Expression._Variable;
    import static pogofish.jadt.samples.ast.Function._Function;
    import static pogofish.jadt.samples.ast.Statement._Return;
    import static pogofish.jadt.samples.ast.Type._Int;
    
    import java.util.HashSet;
    import java.util.List;
    import java.util.Set;
    
    import pogofish.jadt.samples.ast.Expression.Add;
    import pogofish.jadt.samples.ast.Expression.IntLiteral;
    import pogofish.jadt.samples.ast.Expression.LongLiteral;
    import pogofish.jadt.samples.ast.Expression.Variable;
    import pogofish.jadt.samples.ast.Statement.Return;
    
    /**
     * This class shows how to use the code generated by the sample ast
     */
    public class Usage {
    	/**
    	 * Here's an example of creating a complete function using generated factory methods
    	 */
    	public Function sampleFunction() {   
    	       return _Function(_Int(), "addTwo", asList(_Arg(_Int(), "x"), _Arg(_Int(), "y")), asList(
    	               _Return(_Add(_Variable("x"), _Variable("y")))
    	               ));
    	}
    	
    	/**
    	 * Here's a sample function that returns all the integer literals in an expression
         */
    	public Set<Integer> expressionLiterals(Expression expression) {
    	    return expression.accept(new Expression.Visitor<Set<Integer>>() {
    	        @Override
    	        public Set<Integer> visit(Add x) {
    	            final Set<Integer> results = expressionLiterals(x.left);
    	            results.addAll(expressionLiterals(x.right));
    	            return results;
    	        }
    
    	        @Override
    	        public Set<Integer> visit(Variable x) {
    	            return new HashSet<Integer>();
    	        }
    
    	        @Override
    	        public Set<Integer> visit(IntLiteral x) {
    	            return new HashSet<Integer>(asList(x.value));
    	        }
    
    			@Override
    			public Set<Integer> visit(LongLiteral x) {
    	            return new HashSet<Integer>();
    			}
    	    });
    	}
    
    	/**
    	 * And here's a sample function that returns true only if a list of statements has a return statement. 
    	 * Unlike the previous example, this one uses a VisitorWithDefault so that only relevant cases need 
    	 * to be considered.
    	 */
    	public boolean hasReturn(List<Statement> statements) {
    	    boolean hasReturn = false;
    	    for (Statement statement : statements) {
    	        hasReturn = hasReturn || statement.accept(new Statement.VisitorWithDefault<Boolean>() {                
    	            @Override
    	            public Boolean visit(Return x) {
    	                return true;
    	            }
    
    	            @Override
    	            public Boolean getDefault(Statement x) {
    	                return false;
    	            }});
    	    }
    	    return hasReturn;
    	}
    
    }
