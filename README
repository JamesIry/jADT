JADT generates .java source files from algebraic datatype description files. The resulting Java is sealed against extension and automatically gets a visitor interface, an abstract visitor class that computes a default on all constructor types; and methods for equals, hashCode, and toString

SYNTAX

The syntax of a jadt file is

DOC : PACKAGE IMPORTS DATATYPES
PACKAGE : "package" PACKAGENAME
IMPORTS : IMPORT*
IMPORT : "import" PACKAGENAME
DATATYPE : DATATYPE+
DATATYPE : "data" DATATYPENAME "=" CONSTRUCTORS
DATATYPENAME : IDENTIFIER
CONSTRUCTORS : CONSTRUCTOR ("|" CONSTRUCTORS)?
CONSTRUCTOR : CONSTRUCTORNAME ("(" ARGS ")")?
ARGS : ARG ("," ARGS)?
ARG : TYPE ARGNAME
TYPE : TYPENAME ("<" TYPELIST ">")?
TYPELIST : TYPE ("," TYPELIST )?
TYPENAME : IDENTIFIER
ARGNAME : IDENTIFIER
PACKAGENAME : valid Java package name
IDENTIFIER : valid Java identifier

In general whitespace isn't significant other than for separating tokens and end of line characters are just treated as whitespace

Here's a sample AST for a fragment of a language

package pogofish.jadt.sampleast

import java.util.List

data Type =
     Int
   | Long
   
data Function = FunctionDef(Type returnType, String name, List<Arg> args, List<Statement> statements)

data Arg = ArgDef(Type type, String name)

data Statement =
    Declaration(Type type, String name, Expression expression)
  | Assignment(String name, Expression expression)

data Expression =
    Add(Expression left, Expression right)
  | Variable(String name)
  | Literal(int value)

KNOWN LIMITATIONS

* Currently there's no way to create a parameterized (generic) ADT.  So no "data Option A = Some(A value) | None". Should be easy to fix, I just haven't gotten around to it.
* ADTs with only a single constructor are dones stupidly.  Who needs a whole sealed hierarchy/visitor system for what can basically be handled as a glorified data only class? Just needs two different emitters for constructors.
* Constructors cannot have the same name as the data type.  That restriction could be lifted for single constructor ADTs once those are handles specially, but it's not clear how to lift that restriction for multi-constructor ADTs.
* The aforementioned limitation isn't enforced by JADT - the java compiler just pukes all over the generated code. This is VERY easy to fix.
