 /*Copyright 2012 James IryLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License. */options{  FORCE_LA_CHECK = true;  STATIC = false;  SUPPORT_CLASS_VISIBILITY_PUBLIC = true;  ERROR_REPORTING = true;  JAVA_UNICODE_ESCAPE = true;  UNICODE_INPUT = true;  COMMON_TOKEN_ACTION = false;}PARSER_BEGIN(BaseJavaCCParserImpl)/*Copyright 2012 James IryLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License. */package com.pogofish.jadt.parser.javacc;import java.util.ArrayList;import java.util.List;import com.pogofish.jadt.ast.*;import static com.pogofish.jadt.ast.Arg.*;import static com.pogofish.jadt.ast.ArgModifier.*;import static com.pogofish.jadt.ast.Constructor.*;import static com.pogofish.jadt.ast.DataType.*;import static com.pogofish.jadt.ast.Doc.*;import static com.pogofish.jadt.ast.PrimitiveType.*;import static com.pogofish.jadt.ast.RefType.*;import static com.pogofish.jadt.ast.Type.*;/** * This class is automatically generated from jADT.jj.  Do not edit directly. * it's abstract because as much as possible of its implementation is placed * in a sublcass so that Java code can be edited in a .java file instead * of a .cc file. */abstract class BaseJavaCCParserImpl{  /**   * Get information about the source that created this parser   */  abstract String getSrcInfo();  /**     * Called by the parser when ever a good token is recognized by normal parser     * activity.     */  abstract void recovered();  /**     * Called by the parser whenever a required identifier is missing to generate     * a fresh identifier and possibly consume a token     */  abstract String badIdentifier(String expected);  /**	 * If not currently recovering, adds an error to the errors list and sets recovering to true.	 * Actual is assumed to be the last symbol from the tokenizer.		 * @param expected the kind of thing expected	 */  abstract void error(String expected);}PARSER_END(BaseJavaCCParserImpl)/** * A jADT document has an optional package followed by imports and datatypes and ends with an end of file. */Doc doc() :{  String pkg = "";  final List < String > imports;  final List < DataType > dataTypes;}{  (    pkg = pkg()  )?  imports = imports() dataTypes = dataTypes() eof()  {    return _Doc(getSrcInfo(), pkg, imports, dataTypes);  }}/** * The package declaration (if it exists) is the keyword "package" followed by a package name.  No semicolon required. */String pkg() :{  final String pkgName;}{  packageKeyword() pkgName = packageName()  {    return pkgName;  }}/** *     A jADT document may specify any number (including 0) of package names to import. */List < String > imports() :{  final List < String > results = new ArrayList < String > ();  String imprt;}{  (    imprt = singleImport()    {      results.add(imprt);    }  )*  {    return results;  }}/** * Each import is the keyword "import" followed by a package name. */String singleImport() :{  final String pkgName;}{  importKeyword() pkgName = packageName()  {    return pkgName;  }}/** * A package name used in a package or import declaration must be a valid Java package name. */String packageName() :{  final String pkgName;}{  pkgName = dottedIdentifier("a package name")  {    return pkgName;  }}/** *     A jADT document must have at least one datatype, but may have as many as you'd like.*/List < DataType > dataTypes() :{  final List < DataType > dataTypes = new ArrayList < DataType > ();  DataType dataType;}{  (    dataType = dataType()    {      dataTypes.add(dataType);    }  )+  {    return dataTypes;  }}/** * Each datatype consists of a name, optional type arguments, "=" and a list of constructors. */DataType dataType() :{  final String name;  List < String > typeArguments = new ArrayList < String > ();  final List < Constructor > constructors;}{  name = dataTypeName()  (    typeArguments = typeArguments()  )?  equals() constructors = constructors()  {    return _DataType(name, typeArguments, constructors);  }}/** * A data type name is any valid Java identifier not qualified with a package. */String dataTypeName() :{  final String dataTypeName;}{  dataTypeName = identifier("a data type name")  {    return dataTypeName;  }}/** * A data type's type arguments, if it has them, start with '<', have 1 or more arguments, and end with '>'. */List < String > typeArguments() :{  final List < String > typeArguments = new ArrayList < String > ();  String typeArgument;}{  langle() typeArgument = typeArgument()  {    typeArguments.add(typeArgument);  }  (    comma() typeArgument = typeArgument()    {      typeArguments.add(typeArgument);    }  )*  rangle()  {    return typeArguments;  }}/** * A single type argument is any valid Java identifier, not qualified with a package. */String typeArgument() :{  final String typeArgument;}{  typeArgument = identifier("a type parameter")  {    return typeArgument;  }}/** * A data type must have 1 or more case constructors separated by '|'. */List < Constructor > constructors() :{  final List < Constructor > constructors = new ArrayList < Constructor > ();  Constructor constructor;}{  constructor = constructor()  {    constructors.add(constructor);  }  (    bar() constructor = constructor()    {      constructors.add(constructor);    }  )*  {    return constructors;  }}/** * A case constructor is a name optionally followed by arguments.  If it has no arguments then it must not be followed by '()'. */Constructor constructor() :{  final String name;  List < Arg > args = new ArrayList < Arg > ();}{  name = constructorName()  (    args = args()  )?  {    return _Constructor(name, args);  }}/** * A case constructor name is any valid Java identifier not qualified by a package. */String constructorName() :{  final String constructorName;}{  constructorName = identifier("a constructor name")  {    return constructorName;  }}/** * If a case constructor arguments then they must start with '(', have 1 ore more arguments separated by ',' and end with ')'. */List < Arg > args() :{  final List < Arg > args = new ArrayList < Arg > ();  Arg arg;}{  lparen() arg = arg()  {    args.add(arg);  }  (    comma() arg = arg()    {      args.add(arg);    }  )*  rparen()  {    return args;  }}/** * A case constructor argument is a list of modifiers, a type, and then a name. */Arg arg() :{  final List < ArgModifier > modifiers;  final Type type;  final String name;}{  modifiers = argModifiers() type = type() name = argName()  {    return _Arg(modifiers, type, name);  }}/** * A case constructor argument may have 0 or more modifiers separated by spaces. */List < ArgModifier > argModifiers() :{  final List < ArgModifier > argModifiers = new ArrayList < ArgModifier > ();  ArgModifier argModifier;}{  (    argModifier = argModifier()    {      argModifiers.add(argModifier);    }  )*  {    return argModifiers;  }}/** * Currently the only argument modifier allowed is 'final' but others will follow. */ArgModifier argModifier() :{  final ArgModifier argModifier;}{  argModifier = finalKeyword()  {    return argModifier;  }}/** * An argument name is any valid Java identifier not qualified by a package */String argName() :{  final String argName;}{  argName = identifier("an argument name")  {    return argName;  }}/** * A type is either a class type or a primitive type wrapped in 0 or more levels of array */Type type() :{  Type type;  final RefType classType;  final PrimitiveType primitiveType;}{  try  {    (classType = classType()    {      type = _Ref(classType);    }  | primitiveType = primitiveType()    {      type = _Primitive(primitiveType);    }    )  }  catch (ParseException e)  {    type = _Ref(classType());  }  (    arrayTypeBrackets()    {      type = _Ref(_ArrayType(type));    }  )*  {    return type;  }}/** * A refType is either a primitive type wrapped in one level or array or a class type and in either case * may be wrapped in 0 or more additional levels of array */RefType refType() :{  RefType refType;  final PrimitiveType primitiveType;}{  try  {    (refType = classType()  | (primitiveType = primitiveType() lbracket() rbracket()    {      refType = _ArrayType(_Primitive(primitiveType));    }    ))  }  catch (ParseException e)  {    refType = classType();  }  (    arrayTypeBrackets()    {      refType = _ArrayType(_Ref(refType));    }  )*  {    return refType;  }}/** * The pair '[]' modifies a previously mentioned type X to make it type X[] */void arrayTypeBrackets() :{}{  lbracket() rbracket()}/** * A class type is a class name followed by actual type arguments */RefType classType() :{  final String className;  List < RefType > actualTypeArguments = new ArrayList < RefType > ();}{  className = className()  (    actualTypeArguments = actualTypeArguments()  )?  {    return _ClassType(className, actualTypeArguments);  }}/** * A class name is a valid Java class name that may be qualified by a package. */String className() :{  final String className;}{  className = dottedIdentifier("a class name")  {    return className;  }}/** * If a type has type arguments then it will be '<' followed by 1 or more refTypes followed by '>'. */List < RefType > actualTypeArguments() :{  final List < RefType > actualTypeArguments = new ArrayList < RefType > ();  RefType refType;}{  langle() refType = refType()  {    actualTypeArguments.add(refType);  }  (    comma() refType = refType()    {      actualTypeArguments.add(refType);    }  )*  rangle()  {    return actualTypeArguments;  }}/** * A primitive type is any of the standard Java primitive types */PrimitiveType primitiveType() :{  PrimitiveType p;}{  try  {    (p = booleanType()  | p = byteType()  | p = charType()  | p = shortType()  | p = intType()  | p = longType()  | p = floatType()  | p = doubleType())  }  catch (ParseException e)  {    error("a primitive type");    p = booleanType();  }  {    return p;  }}/** * A dotted identifier is a series of 1 or more identifiers separated by '.'. */String dottedIdentifier(String expected) :{  String id;  final StringBuilder builder;}{  id = identifier(expected)  {    builder = new StringBuilder(id);  }  (    dot() id = identifier(expected)    {      builder.append('.');      builder.append(id);    }  )*  {    return builder.toString();  }}/** * An identifier may be any valid Java identifier */String identifier(String expected) :{}{  try  {    < IDENTIFIER >    {      recovered();      return token.image;    }  }  catch (ParseException e)  {    return badIdentifier(expected);  }}/** * 'import' */void importKeyword() :{}{  try  {    < IMPORT >    {      recovered();    }  }  catch (ParseException e)  {    error("'import'");  }}/** * 'package' */void packageKeyword() :{}{  try  {    < PACKAGE >    {      recovered();    }  }  catch (ParseException e)  {    error("'package'");  }}/** * 'final' */ArgModifier finalKeyword() :{}{  try  {    < FINAL >    {      recovered();    }  }  catch (ParseException e)  {    error("'final'");  }  {    return _Final();  }}/** * 'boolean' */PrimitiveType booleanType() :{}{  try  {    < BOOLEAN >    {      recovered();    }  }  catch (ParseException e)  {    error("'boolean'");  }  {    return _BooleanType();  }}/** * 'byte' */PrimitiveType byteType() :{}{  try  {    < BYTE >    {      recovered();    }  }  catch (ParseException e)  {    error("'byte'");  }  {    return _ByteType();  }}/** * 'char' */PrimitiveType charType() :{}{  try  {    < CHAR >    {      recovered();    }  }  catch (ParseException e)  {    error("'char'");  }  {    return _CharType();  }}/** * 'short' */PrimitiveType shortType() :{}{  try  {    < SHORT >    {      recovered();    }  }  catch (ParseException e)  {    error("'short'");  }  {    return _ShortType();  }}/** * 'int' */PrimitiveType intType() :{}{  try  {    < INT >    {      recovered();    }  }  catch (ParseException e)  {    error("'int'");  }  {    return _IntType();  }}/** * 'long' */PrimitiveType longType() :{}{  try  {    < LONG >    {      recovered();    }  }  catch (ParseException e)  {    error("'long'");  }  {    return _LongType();  }}/** * 'float' */PrimitiveType floatType() :{}{  try  {    < FLOAT >    {      recovered();    }  }  catch (ParseException e)  {    error("'float'");  }  {    return _FloatType();  }}/** * 'double' */PrimitiveType doubleType() :{}{  try  {    < DOUBLE >    {      recovered();    }  }  catch (ParseException e)  {    error("'double'");  }  {    return _DoubleType();  }}/** * '.' */void dot() :{}{  try  {    < DOT >    {      recovered();    }  }  catch (ParseException e)  {    error("'.'");  }}/** * ',' */void comma() :{}{  try  {    < COMMA >    {      recovered();    }  }  catch (ParseException e)  {    error("','");  }}/** * '(' */void lparen() :{}{  try  {    < LPAREN >    {      recovered();    }  }  catch (ParseException e)  {    error("'('");  }}/** * ')' */void rparen() :{}{  try  {    < RPAREN >    {      recovered();    }  }  catch (ParseException e)  {    error("')'");  }}/** * '[' */void lbracket() :{}{  try  {    < LBRACKET >    {      recovered();    }  }  catch (ParseException e)  {    error("'['");  }}/** * ']' */void rbracket() :{}{  try  {    < RBRACKET >    {      recovered();    }  }  catch (ParseException e)  {    error("']'");  }}/** * '<' */void langle() :{}{  try  {    < LANGLE >    {      recovered();    }  }  catch (ParseException e)  {    error("'<'");  }}/** * '>' */void rangle() :{}{  try  {    < RANGLE >    {      recovered();    }  }  catch (ParseException e)  {    error("'>'");  }}/** * '=' */void equals() :{}{  try  {    < EQUALS >    {      recovered();    }  }  catch (ParseException e)  {    error("'='");  }}/** * '|' */void bar() :{}{  try  {    < BAR >    {      recovered();    }  }  catch (ParseException e)  {    error("'|'");  }}/** * end of file */void eof() :{}{  try  {    < EOF >    {      recovered();    }  }  catch (ParseException e)  {    error("<EOF>");  }}// ********************************* TOKENS **********************************/** * Punctuation used by jADT */TOKEN :{  < LANGLE : "<" >| < RANGLE : ">" >| < EQUALS : "=" >| < LPAREN : "(" >| < RPAREN : ")" >| < COMMA : "," >| < BAR : "|" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < DOT : "." >}/** * jADT keywords */TOKEN :{ < IMPORT : "import" >| < PACKAGE : "package" >| < FINAL : "final" >}/** * Java primitive types */TOKEN :{  < BOOLEAN : "boolean" >| < BYTE : "byte" >| < CHAR : "char" >| < SHORT : "short" >| < INT : "int" >| < LONG : "long" >| < FLOAT : "float" >| < DOUBLE : "double" >}/** * Most Java keywords are unused but reserved so they can't be used in an jADT definition and thus screw up the generated Java */TOKEN :      {   < JAVA_KEYWORD :    "abstract"  | "assert"  | "break"  | "case"  | "catch"  | "class"  | "const"  | "continue"  | "default"  | "do"  | "else"  | "enum"  | "extends"  | "finally"  | "for"  | "goto"  | "if"  | "implements"  | "instanceof"  | "interface"  | "native"  | "new"  | "private"  | "protected"  | "public"  | "return"  | "static"  | "strictfp"  | "super"  | "switch"  | "synchronized"  | "this"  | "throw"  | "throws"  | "transient"  | "try"  | "void"  | "volatile"  | "while" >}/** * An identifier is any valid Java identifier.  It must start with a unicode 'letter', '$' or '_' and be followed * by arbitrarily many unicode 'letters', unicode 'digits', '$', or '_' */TOKEN :{  < IDENTIFIER :    < IDENTIFIER_START >    (      < IDENTIFIER_START >    | < IDENTIFIER_PART >    )* >| < #IDENTIFIER_START : [ // all characters that return true from Character.isJavaIdentifierStart    "\u0024" /* $ */, "\u0041"-"\u005a" /* A - Z */, "\u005f" /* _ */, "\u0061"-"\u007a" /* a - z */, "\u00a2"-"\u00a5" /* ¢ - ´ */, "\u00aa" /* » */, "\u00b5" /* µ */, "\u00ba" /* ¼ */, "\u00c0"-"\u00d6" /* Ë - … */, "\u00d8"-"\u00f6" /* ¯ - š */, "\u00f8"-"\u0236" /* ¿ - ? */, "\u0250"-"\u02c1" /* ? - ? */, "\u02c6"-"\u02d1" /* ö - ? */, "\u02e0"-"\u02e4" /* ? - ? */, "\u02ee" /* ? */, "\u037a" /* ? */, "\u0386" /* ? */, "\u0388"-"\u038a" /* ? - ? */, "\u038c" /* ? */, "\u038e"-"\u03a1" /* ? - ? */, "\u03a3"-"\u03ce" /* ? - ? */, "\u03d0"-"\u03f5" /* ? - ? */, "\u03f7"-"\u03fb" /* ? - ? */, "\u0400"-"\u0481" /* ? - ? */, "\u048a"-"\u04ce" /* ? - ? */, "\u04d0"-"\u04f5" /* ? - ? */, "\u04f8"-"\u04f9" /* ? - ? */, "\u0500"-"\u050f" /* ? - ? */, "\u0531"-"\u0556" /* ? - ? */, "\u0559" /* ? */, "\u0561"-"\u0587" /* ? - ? */, "\u05d0"-"\u05ea" /* ? - ? */, "\u05f0"-"\u05f2" /* ? - ? */, "\u0621"-"\u063a" /* ? - ? */, "\u0640"-"\u064a" /* ? - ? */, "\u066e"-"\u066f" /* ? - ? */, "\u0671"-"\u06d3" /* ? - ? */, "\u06d5" /* ? */, "\u06e5"-"\u06e6" /* ? - ? */, "\u06ee"-"\u06ef" /* ? - ? */, "\u06fa"-"\u06fc" /* ? - ? */, "\u06ff" /* ? */, "\u0710" /* ? */, "\u0712"-"\u072f" /* ? - ? */, "\u074d"-"\u074f" /* ? - ? */, "\u0780"-"\u07a5" /* ? - ? */, "\u07b1" /* ? */, "\u0904"-"\u0939" /* ? - ? */, "\u093d" /* ? */, "\u0950" /* ? */, "\u0958"-"\u0961" /* ? - ? */, "\u0985"-"\u098c" /* ? - ? */, "\u098f"-"\u0990" /* ? - ? */, "\u0993"-"\u09a8" /* ? - ? */, "\u09aa"-"\u09b0" /* ? - ? */, "\u09b2" /* ? */, "\u09b6"-"\u09b9" /* ? - ? */, "\u09bd" /* ? */, "\u09dc"-"\u09dd" /* ? - ? */, "\u09df"-"\u09e1" /* ? - ? */, "\u09f0"-"\u09f3" /* ? - ? */, "\u0a05"-"\u0a0a" /* ? - ? */, "\u0a0f"-"\u0a10" /* ? - ? */, "\u0a13"-"\u0a28" /* ? - ? */, "\u0a2a"-"\u0a30" /* ? - ? */, "\u0a32"-"\u0a33" /* ? - ? */, "\u0a35"-"\u0a36" /* ? - ? */, "\u0a38"-"\u0a39" /* ? - ? */, "\u0a59"-"\u0a5c" /* ? - ? */, "\u0a5e" /* ? */, "\u0a72"-"\u0a74" /* ? - ? */, "\u0a85"-"\u0a8d" /* ? - ? */, "\u0a8f"-"\u0a91" /* ? - ? */, "\u0a93"-"\u0aa8" /* ? - ? */, "\u0aaa"-"\u0ab0" /* ? - ? */, "\u0ab2"-"\u0ab3" /* ? - ? */, "\u0ab5"-"\u0ab9" /* ? - ? */, "\u0abd" /* ? */, "\u0ad0" /* ? */, "\u0ae0"-"\u0ae1" /* ? - ? */, "\u0af1" /* ? */, "\u0b05"-"\u0b0c" /* ? - ? */, "\u0b0f"-"\u0b10" /* ? - ? */, "\u0b13"-"\u0b28" /* ? - ? */, "\u0b2a"-"\u0b30" /* ? - ? */, "\u0b32"-"\u0b33" /* ? - ? */, "\u0b35"-"\u0b39" /* ? - ? */, "\u0b3d" /* ? */, "\u0b5c"-"\u0b5d" /* ? - ? */, "\u0b5f"-"\u0b61" /* ? - ? */, "\u0b71" /* ? */, "\u0b83" /* ? */, "\u0b85"-"\u0b8a" /* ? - ? */, "\u0b8e"-"\u0b90" /* ? - ? */, "\u0b92"-"\u0b95" /* ? - ? */, "\u0b99"-"\u0b9a" /* ? - ? */, "\u0b9c" /* ? */, "\u0b9e"-"\u0b9f" /* ? - ? */, "\u0ba3"-"\u0ba4" /* ? - ? */, "\u0ba8"-"\u0baa" /* ? - ? */, "\u0bae"-"\u0bb5" /* ? - ? */, "\u0bb7"-"\u0bb9" /* ? - ? */, "\u0bf9" /* ? */, "\u0c05"-"\u0c0c" /* ? - ? */, "\u0c0e"-"\u0c10" /* ? - ? */, "\u0c12"-"\u0c28" /* ? - ? */, "\u0c2a"-"\u0c33" /* ? - ? */, "\u0c35"-"\u0c39" /* ? - ? */, "\u0c60"-"\u0c61" /* ? - ? */, "\u0c85"-"\u0c8c" /* ? - ? */, "\u0c8e"-"\u0c90" /* ? - ? */, "\u0c92"-"\u0ca8" /* ? - ? */, "\u0caa"-"\u0cb3" /* ? - ? */, "\u0cb5"-"\u0cb9" /* ? - ? */, "\u0cbd" /* ? */, "\u0cde" /* ? */, "\u0ce0"-"\u0ce1" /* ? - ? */, "\u0d05"-"\u0d0c" /* ? - ? */, "\u0d0e"-"\u0d10" /* ? - ? */, "\u0d12"-"\u0d28" /* ? - ? */, "\u0d2a"-"\u0d39" /* ? - ? */, "\u0d60"-"\u0d61" /* ? - ? */, "\u0d85"-"\u0d96" /* ? - ? */, "\u0d9a"-"\u0db1" /* ? - ? */, "\u0db3"-"\u0dbb" /* ? - ? */, "\u0dbd" /* ? */, "\u0dc0"-"\u0dc6" /* ? - ? */, "\u0e01"-"\u0e30" /* ? - ? */, "\u0e32"-"\u0e33" /* ? - ? */, "\u0e3f"-"\u0e46" /* ? - ? */, "\u0e81"-"\u0e82" /* ? - ? */, "\u0e84" /* ? */, "\u0e87"-"\u0e88" /* ? - ? */, "\u0e8a" /* ? */, "\u0e8d" /* ? */, "\u0e94"-"\u0e97" /* ? - ? */, "\u0e99"-"\u0e9f" /* ? - ? */, "\u0ea1"-"\u0ea3" /* ? - ? */, "\u0ea5" /* ? */, "\u0ea7" /* ? */, "\u0eaa"-"\u0eab" /* ? - ? */, "\u0ead"-"\u0eb0" /* ? - ? */, "\u0eb2"-"\u0eb3" /* ? - ? */, "\u0ebd" /* ? */, "\u0ec0"-"\u0ec4" /* ? - ? */, "\u0ec6" /* ? */, "\u0edc"-"\u0edd" /* ? - ? */, "\u0f00" /* ? */, "\u0f40"-"\u0f47" /* ? - ? */, "\u0f49"-"\u0f6a" /* ? - ? */, "\u0f88"-"\u0f8b" /* ? - ? */, "\u1000"-"\u1021" /* ? - ? */, "\u1023"-"\u1027" /* ? - ? */, "\u1029"-"\u102a" /* ? - ? */, "\u1050"-"\u1055" /* ? - ? */, "\u10a0"-"\u10c5" /* ? - ? */, "\u10d0"-"\u10f8" /* ? - ? */, "\u1100"-"\u1159" /* ? - ? */, "\u115f"-"\u11a2" /* ? - ? */, "\u11a8"-"\u11f9" /* ? - ? */, "\u1200"-"\u1206" /* ? - ? */, "\u1208"-"\u1246" /* ? - ? */, "\u1248" /* ? */, "\u124a"-"\u124d" /* ? - ? */, "\u1250"-"\u1256" /* ? - ? */, "\u1258" /* ? */, "\u125a"-"\u125d" /* ? - ? */, "\u1260"-"\u1286" /* ? - ? */, "\u1288" /* ? */, "\u128a"-"\u128d" /* ? - ? */, "\u1290"-"\u12ae" /* ? - ? */, "\u12b0" /* ? */, "\u12b2"-"\u12b5" /* ? - ? */, "\u12b8"-"\u12be" /* ? - ? */, "\u12c0" /* ? */, "\u12c2"-"\u12c5" /* ? - ? */, "\u12c8"-"\u12ce" /* ? - ? */, "\u12d0"-"\u12d6" /* ? - ? */, "\u12d8"-"\u12ee" /* ? - ? */, "\u12f0"-"\u130e" /* ? - ? */, "\u1310" /* ? */, "\u1312"-"\u1315" /* ? - ? */, "\u1318"-"\u131e" /* ? - ? */, "\u1320"-"\u1346" /* ? - ? */, "\u1348"-"\u135a" /* ? - ? */, "\u13a0"-"\u13f4" /* ? - ? */, "\u1401"-"\u166c" /* ? - ? */, "\u166f"-"\u1676" /* ? - ? */, "\u1681"-"\u169a" /* ? - ? */, "\u16a0"-"\u16ea" /* ? - ? */, "\u16ee"-"\u16f0" /* ? - ? */, "\u1700"-"\u170c" /* ? - ? */, "\u170e"-"\u1711" /* ? - ? */, "\u1720"-"\u1731" /* ? - ? */, "\u1740"-"\u1751" /* ? - ? */, "\u1760"-"\u176c" /* ? - ? */, "\u176e"-"\u1770" /* ? - ? */, "\u1780"-"\u17b3" /* ? - ? */, "\u17d7" /* ? */, "\u17db"-"\u17dc" /* ? - ? */, "\u1820"-"\u1877" /* ? - ? */, "\u1880"-"\u18a8" /* ? - ? */, "\u1900"-"\u191c" /* ? - ? */, "\u1950"-"\u196d" /* ? - ? */, "\u1970"-"\u1974" /* ? - ? */, "\u1d00"-"\u1d6b" /* ? - ? */, "\u1e00"-"\u1e9b" /* ? - ? */, "\u1ea0"-"\u1ef9" /* ? - ? */, "\u1f00"-"\u1f15" /* ? - ? */, "\u1f18"-"\u1f1d" /* ? - ? */, "\u1f20"-"\u1f45" /* ? - ? */, "\u1f48"-"\u1f4d" /* ? - ? */, "\u1f50"-"\u1f57" /* ? - ? */, "\u1f59" /* ? */, "\u1f5b" /* ? */, "\u1f5d" /* ? */, "\u1f5f"-"\u1f7d" /* ? - ? */, "\u1f80"-"\u1fb4" /* ? - ? */, "\u1fb6"-"\u1fbc" /* ? - ? */, "\u1fbe" /* ? */, "\u1fc2"-"\u1fc4" /* ? - ? */, "\u1fc6"-"\u1fcc" /* ? - ? */, "\u1fd0"-"\u1fd3" /* ? - ? */, "\u1fd6"-"\u1fdb" /* ? - ? */, "\u1fe0"-"\u1fec" /* ? - ? */, "\u1ff2"-"\u1ff4" /* ? - ? */, "\u1ff6"-"\u1ffc" /* ? - ? */, "\u203f"-"\u2040" /* ? - ? */, "\u2054" /* ? */, "\u2071" /* ? */, "\u207f" /* ? */, "\u20a0"-"\u20b1" /* ? - ? */, "\u2102" /* ? */, "\u2107" /* ? */, "\u210a"-"\u2113" /* ? - ? */, "\u2115" /* ? */, "\u2119"-"\u211d" /* ? - ? */, "\u2124" /* ? */, "\u2126" /* ? */, "\u2128" /* ? */, "\u212a"-"\u212d" /* ? - ? */, "\u212f"-"\u2131" /* ? - ? */, "\u2133"-"\u2139" /* ? - ? */, "\u213d"-"\u213f" /* ? - ? */, "\u2145"-"\u2149" /* ? - ? */, "\u2160"-"\u2183" /* ? - ? */, "\u3005"-"\u3007" /* ? - ? */, "\u3021"-"\u3029" /* ? - ? */, "\u3031"-"\u3035" /* ? - ? */, "\u3038"-"\u303c" /* ? - ? */, "\u3041"-"\u3096" /* ? - ? */, "\u309d"-"\u309f" /* ? - ? */, "\u30a1"-"\u30ff" /* ? - ? */, "\u3105"-"\u312c" /* ? - ? */, "\u3131"-"\u318e" /* ? - ? */, "\u31a0"-"\u31b7" /* ? - ? */, "\u31f0"-"\u31ff" /* ? - ? */, "\u3400"-"\u4db5" /* ? - ? */, "\u4e00"-"\u9fa5" /* ? - ? */, "\ua000"-"\ua48c" /* ? - ? */, "\uac00"-"\ud7a3" /* ? - ? */, "\uf900"-"\ufa2d" /* ? - ? */, "\ufa30"-"\ufa6a" /* ? - ? */, "\ufb00"-"\ufb06" /* ? - ? */, "\ufb13"-"\ufb17" /* ? - ? */, "\ufb1d" /* ? */, "\ufb1f"-"\ufb28" /* ? - ? */, "\ufb2a"-"\ufb36" /* ? - ? */, "\ufb38"-"\ufb3c" /* ? - ? */, "\ufb3e" /* ? */, "\ufb40"-"\ufb41" /* ? - ? */, "\ufb43"-"\ufb44" /* ? - ? */, "\ufb46"-"\ufbb1" /* ? - ? */, "\ufbd3"-"\ufd3d" /* ? - ? */, "\ufd50"-"\ufd8f" /* ? - ? */, "\ufd92"-"\ufdc7" /* ? - ? */, "\ufdf0"-"\ufdfc" /* ? - ? */, "\ufe33"-"\ufe34" /* ? - ? */, "\ufe4d"-"\ufe4f" /* ? - ? */, "\ufe69" /* ? */, "\ufe70"-"\ufe74" /* ? - ? */, "\ufe76"-"\ufefc" /* ? - ? */, "\uff04" /* ? */, "\uff21"-"\uff3a" /* ? - ? */, "\uff3f" /* ? */, "\uff41"-"\uff5a" /* ? - ? */, "\uff65"-"\uffbe" /* ? - ? */, "\uffc2"-"\uffc7" /* ? - ? */, "\uffca"-"\uffcf" /* ? - ? */, "\uffd2"-"\uffd7" /* ? - ? */, "\uffda"-"\uffdc" /* ? - ? */, "\uffe0"-"\uffe1" /* ? - ? */, "\uffe5"-"\uffe6" /* ? - ? */] >| < #IDENTIFIER_PART : [ // all characters that return true from Character.isJavaIdentifierPart but not from isJavaIdentifierStart    "\u0000"-"\u0008" /*   -  */, "\u000e"-"\u001b" /*  -  */, "\u0030"-"\u0039" /* 0 - 9 */, "\u007f"-"\u009f" /*  - ? */, "\u00ad" /* ? */, "\u0300"-"\u0357" /* ? - ? */, "\u035d"-"\u036f" /* ? - ? */, "\u0483"-"\u0486" /* ? - ? */, "\u0591"-"\u05a1" /* ? - ? */, "\u05a3"-"\u05b9" /* ? - ? */, "\u05bb"-"\u05bd" /* ? - ? */, "\u05bf" /* ? */, "\u05c1"-"\u05c2" /* ? - ? */, "\u05c4" /* ? */, "\u0600"-"\u0603" /* ? - ? */, "\u0610"-"\u0615" /* ? - ? */, "\u064b"-"\u0658" /* ? - ? */, "\u0660"-"\u0669" /* ? - ? */, "\u0670" /* ? */, "\u06d6"-"\u06dd" /* ? - ? */, "\u06df"-"\u06e4" /* ? - ? */, "\u06e7"-"\u06e8" /* ? - ? */, "\u06ea"-"\u06ed" /* ? - ? */, "\u06f0"-"\u06f9" /* ? - ? */, "\u070f" /* ? */, "\u0711" /* ? */, "\u0730"-"\u074a" /* ? - ? */, "\u07a6"-"\u07b0" /* ? - ? */, "\u0901"-"\u0903" /* ? - ? */, "\u093c" /* ? */, "\u093e"-"\u094d" /* ? - ? */, "\u0951"-"\u0954" /* ? - ? */, "\u0962"-"\u0963" /* ? - ? */, "\u0966"-"\u096f" /* ? - ? */, "\u0981"-"\u0983" /* ? - ? */, "\u09bc" /* ? */, "\u09be"-"\u09c4" /* ? - ? */, "\u09c7"-"\u09c8" /* ? - ? */, "\u09cb"-"\u09cd" /* ? - ? */, "\u09d7" /* ? */, "\u09e2"-"\u09e3" /* ? - ? */, "\u09e6"-"\u09ef" /* ? - ? */, "\u0a01"-"\u0a03" /* ? - ? */, "\u0a3c" /* ? */, "\u0a3e"-"\u0a42" /* ? - ? */, "\u0a47"-"\u0a48" /* ? - ? */, "\u0a4b"-"\u0a4d" /* ? - ? */, "\u0a66"-"\u0a71" /* ? - ? */, "\u0a81"-"\u0a83" /* ? - ? */, "\u0abc" /* ? */, "\u0abe"-"\u0ac5" /* ? - ? */, "\u0ac7"-"\u0ac9" /* ? - ? */, "\u0acb"-"\u0acd" /* ? - ? */, "\u0ae2"-"\u0ae3" /* ? - ? */, "\u0ae6"-"\u0aef" /* ? - ? */, "\u0b01"-"\u0b03" /* ? - ? */, "\u0b3c" /* ? */, "\u0b3e"-"\u0b43" /* ? - ? */, "\u0b47"-"\u0b48" /* ? - ? */, "\u0b4b"-"\u0b4d" /* ? - ? */, "\u0b56"-"\u0b57" /* ? - ? */, "\u0b66"-"\u0b6f" /* ? - ? */, "\u0b82" /* ? */, "\u0bbe"-"\u0bc2" /* ? - ? */, "\u0bc6"-"\u0bc8" /* ? - ? */, "\u0bca"-"\u0bcd" /* ? - ? */, "\u0bd7" /* ? */, "\u0be7"-"\u0bef" /* ? - ? */, "\u0c01"-"\u0c03" /* ? - ? */, "\u0c3e"-"\u0c44" /* ? - ? */, "\u0c46"-"\u0c48" /* ? - ? */, "\u0c4a"-"\u0c4d" /* ? - ? */, "\u0c55"-"\u0c56" /* ? - ? */, "\u0c66"-"\u0c6f" /* ? - ? */, "\u0c82"-"\u0c83" /* ? - ? */, "\u0cbc" /* ? */, "\u0cbe"-"\u0cc4" /* ? - ? */, "\u0cc6"-"\u0cc8" /* ? - ? */, "\u0cca"-"\u0ccd" /* ? - ? */, "\u0cd5"-"\u0cd6" /* ? - ? */, "\u0ce6"-"\u0cef" /* ? - ? */, "\u0d02"-"\u0d03" /* ? - ? */, "\u0d3e"-"\u0d43" /* ? - ? */, "\u0d46"-"\u0d48" /* ? - ? */, "\u0d4a"-"\u0d4d" /* ? - ? */, "\u0d57" /* ? */, "\u0d66"-"\u0d6f" /* ? - ? */, "\u0d82"-"\u0d83" /* ? - ? */, "\u0dca" /* ? */, "\u0dcf"-"\u0dd4" /* ? - ? */, "\u0dd6" /* ? */, "\u0dd8"-"\u0ddf" /* ? - ? */, "\u0df2"-"\u0df3" /* ? - ? */, "\u0e31" /* ? */, "\u0e34"-"\u0e3a" /* ? - ? */, "\u0e47"-"\u0e4e" /* ? - ? */, "\u0e50"-"\u0e59" /* ? - ? */, "\u0eb1" /* ? */, "\u0eb4"-"\u0eb9" /* ? - ? */, "\u0ebb"-"\u0ebc" /* ? - ? */, "\u0ec8"-"\u0ecd" /* ? - ? */, "\u0ed0"-"\u0ed9" /* ? - ? */, "\u0f18"-"\u0f19" /* ? - ? */, "\u0f20"-"\u0f29" /* ? - ? */, "\u0f35" /* ? */, "\u0f37" /* ? */, "\u0f39" /* ? */, "\u0f3e"-"\u0f3f" /* ? - ? */, "\u0f71"-"\u0f84" /* ? - ? */, "\u0f86"-"\u0f87" /* ? - ? */, "\u0f90"-"\u0f97" /* ? - ? */, "\u0f99"-"\u0fbc" /* ? - ? */, "\u0fc6" /* ? */, "\u102c"-"\u1032" /* ? - ? */, "\u1036"-"\u1039" /* ? - ? */, "\u1040"-"\u1049" /* ? - ? */, "\u1056"-"\u1059" /* ? - ? */, "\u1369"-"\u1371" /* ? - ? */, "\u1712"-"\u1714" /* ? - ? */, "\u1732"-"\u1734" /* ? - ? */, "\u1752"-"\u1753" /* ? - ? */, "\u1772"-"\u1773" /* ? - ? */, "\u17b4"-"\u17d3" /* ? - ? */, "\u17dd" /* ? */, "\u17e0"-"\u17e9" /* ? - ? */, "\u180b"-"\u180d" /* ? - ? */, "\u1810"-"\u1819" /* ? - ? */, "\u18a9" /* ? */, "\u1920"-"\u192b" /* ? - ? */, "\u1930"-"\u193b" /* ? - ? */, "\u1946"-"\u194f" /* ? - ? */, "\u200c"-"\u200f" /* ? - ? */, "\u202a"-"\u202e" /* ? - ? */, "\u2060"-"\u2063" /* ? - ? */, "\u206a"-"\u206f" /* ? - ? */, "\u20d0"-"\u20dc" /* ? - ? */, "\u20e1" /* ? */, "\u20e5"-"\u20ea" /* ? - ? */, "\u302a"-"\u302f" /* ? - ? */, "\u3099"-"\u309a" /* ? - ? */, "\ufb1e" /* ? */, "\ufe00"-"\ufe0f" /* ? - ? */, "\ufe20"-"\ufe23" /* ? - ? */, "\ufeff" /* ? */, "\uff10"-"\uff19" /* ? - ? */, "\ufff9"-"\ufffb" /* ? - ? */] >}/** * JavaDoc comments start with '/' '*' '*', have any number of arbitrary characters and end with '*' '/' */SKIP :{  < JAVADOC_COMMENT : "/**" (~["*"] | "*" ~["/"])* ("*/")? >}/** * Java multi line comments start with '/' '*', have any number of arbitrary characters and end with '* '/' */SKIP :{  < JAVA_ML_COMMENT : "/*" (~["*"] | "*" ~["/"])* ("*/")? >}/** * Java end of line comments start with '/' '/', have any number of arbitrary characters * other than end of line (carriage return or line feed), * and end with an end of line (carriage return or line feed) or end of file */SKIP :{  < JAVA_EOL_COMMENT : "//" (~[ "\n", "\r" ])* >}/** * Whitespace is the space character, tab, newline, carriage return, and formfeed.  It is completely ignored except to separate tokens */SKIP :{  // whitespace
  < WS :    " "  | "\t"  | "\n"  | "\r"  | "\f" >  // internal end of line comments
| < INTERNAL_EOL_COMMENT :    "#" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? >}/** * The unknown token type is a catch all used as an aid in error recovery */TOKEN :{  // the only reason this works is that earlier rules pick up tokens before getting here  // an unknown is  // repeated ((slash followed by something that isn't a * or other punctuation) or (anything that isn't punctuation))  // or a solo slash  < UNKNOWN :    (      (        "/"        ~[ "*", "<", ">", "[", "]", "(", ")", "=", ".", "|", ",", " ", "\n", "\r", "\f", "\t", "#", "/" ]      )    | ~[ "<", ">", "[", "]", "(", ")", "=", ".", "|", ",", " ", "\n", "\r", "\f", "\t", "#", "/" ]    )* | "/" >}